(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{51:function(e,t,o){"use strict";o.r(t);var a=o(3),s=function(e){var t,o,a=(o=void 0,(t={}).type="post",t.internal=o,t.contentType="markdown",t.slug="postgres-lvm-snapshot",t.content=o,t.createdAt=new Date(1583172e6),t.updatedAt=new Date(1583204147533),t.title="PostgreSQL LVM Snapshotting",t.date="2020-03-02T12:00:00",t.layout="page",t.markdownHeadings=[{text:"Background",slug:"background",level:2},{text:"LVM",slug:"lvm",level:2},{text:"Loopback",slug:"loopback",level:3},{text:"Ubuntu Thin Provisioning",slug:"ubuntu-thin-provisioning",level:3},{text:"Volumes",slug:"volumes",level:3},{text:"Physical Volumes",slug:"physical-volumes",level:4},{text:"Volume Groups",slug:"volume-groups",level:4},{text:"Logical Volumes",slug:"logical-volumes",level:4},{text:"Snapshotting",slug:"snapshotting",level:3},{text:"Create",slug:"create",level:4},{text:"Revert",slug:"revert",level:4}],t.excerpt='<p>As a test engineer, I need the ability to quickly reset changes I have made to databases, either directly or indirectly.\nMicrosoft SQL Server (MSSQL) has the ability to create and reset database-level snapshots and this functionality has\nproven quite invaluable in my testing. Not only is it easy to create and reset snapshots, but the process is fast--at\nleast, it has been in my use cases. Unfortunately, I also work a lot with PostgreSQL (Postgres) and at the time of this\nwriting, such a snapshot-revert system does not exist. Supposedly the\n<a href="https://www.postgresql.org/docs/10/continuous-archiving.html">Point-in-Time Recovery</a> (PiTR) system can be used to\nsnapshot a database and then revert it, but this involves performing a full database restore and then replaying the\nWAL files until the point the snapshot occurred. This can take quite a bit of time, especially if the database is large.\nI searched to no avail for an open source tool or plugin that would accomplish this task but eventually settled on a\nmethod of using <a href="https://en.wikipedia.org/wiki/Logical_Volume_Manager_(Linux)">Linux LVM</a> to accomplish this task for\nme.</p>\n',t.permalink="/posts/postgres-lvm-snapshot.html",t.assets={},t.attributes=t,t),s=e.options.beforeCreate||[];e.options.beforeCreate=[function(){this.$page=a}].concat(s);["layout","transition"].forEach((function(t){var o=e.options.PageComponent;o&&(e.options[t]=o[t]),void 0===e.options[t]&&(e.options[t]=a[t])})),a.slug&&(e.options.name="page-wrapper-"+a.slug.replace(/[^0-9a-z\-]/gi,"-"))},n=Object(a.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("layout-manager",[o("p",[e._v("As a test engineer, I need the ability to quickly reset changes I have made to databases, either directly or indirectly.\nMicrosoft SQL Server (MSSQL) has the ability to create and reset database-level snapshots and this functionality has\nproven quite invaluable in my testing. Not only is it easy to create and reset snapshots, but the process is fast--at\nleast, it has been in my use cases. Unfortunately, I also work a lot with PostgreSQL (Postgres) and at the time of this\nwriting, such a snapshot-revert system does not exist. Supposedly the\n"),o("saber-link",{attrs:{to:"https://www.postgresql.org/docs/10/continuous-archiving.html"}},[e._v("Point-in-Time Recovery")]),e._v(" (PiTR) system can be used to\nsnapshot a database and then revert it, but this involves performing a full database restore and then replaying the\nWAL files until the point the snapshot occurred. This can take quite a bit of time, especially if the database is large.\nI searched to no avail for an open source tool or plugin that would accomplish this task but eventually settled on a\nmethod of using "),o("saber-link",{attrs:{to:"https://en.wikipedia.org/wiki/Logical_Volume_Manager_(Linux)"}},[e._v("Linux LVM")]),e._v(" to accomplish this task for\nme.")],1),e._v(" "),o("h2",{attrs:{id:"background"}},[e._v("Background")]),e._v(" "),o("p",[e._v("In my testing, I started running Postgres inside Docker because it simplified my setup and deployment. Because I was\nrunning Postgres this way, I started looking for Docker plugins that might allow snapshotting and resetting of\nDocker volumes. My hope was that I could keep the Postgres data directory inside a Docker volume while keeping the\nrest of the system in the main container.")]),e._v(" "),o("p",[e._v("My initial attempt was to try to use the "),o("saber-link",{attrs:{to:"https://github.com/rancher/convoy"}},[e._v("Convoy")]),e._v(" plugin created by the Rancher\nteam. However, I could never get the behavior I desired. Another solution was\n"),o("saber-link",{attrs:{to:"https://github.com/moby/moby/issues/33782"}},[e._v("proposed")]),e._v(" by a team at\n"),o("saber-link",{attrs:{to:"https://netapp.io/2017/06/22/snapshots-clones-docker-volume-paradigm/"}},[e._v("NetApp")]),e._v(". This solution was quite appealing as\nit would have added snapshot and reversion functionality directly to the "),o("code",{pre:!0},[e._v("docker volume")]),e._v(" command. Unfortunately it\nhas since been abandoned.")],1),e._v(" "),o("p",[e._v("A few other solutions were explored but none panned out.")]),e._v(" "),o("h2",{attrs:{id:"lvm"}},[e._v("LVM")]),e._v(" "),o("p",[e._v("Since a pre-existing solution didn't seem to exist it was time to come up with my own. I decided to see if I could make\nuse of the snapshot and restore functionality that is part of LVM. The method in this section was developed with much\nhelp from "),o("saber-link",{attrs:{to:"https://www.tecmint.com/take-snapshot-of-logical-volume-and-restore-in-lvm/"}},[e._v("this TecMint tutorial.")]),e._v(".")],1),e._v(" "),o("h3",{attrs:{id:"loopback"}},[e._v("Loopback")]),e._v(" "),o("p",[e._v("For simplicity, this article uses a file loopback. This is sufficient for development but should never be used for\nproduction. This article assumes a loopback file exists at "),o("code",{pre:!0},[e._v("/var/lib/postgresql/data.vol")]),e._v(" and is mounted at\n"),o("code",{pre:!0},[e._v("/dev/loop5")]),e._v(". You can create and mount it as follows:")]),e._v(" "),o("highlight-code",{attrs:{lang:"bash"}},[o("p",[e._v("sudo su postgres\ntruncate -s 150G /var/lib/postgresql/data.vol\nexit\nsudo losetup /dev/loop5 /var/lib/postgresql/data.vol\n")])]),o("p"),e._v(" "),o("p",[e._v("Note, I chose 150G as this size is sufficient for the database I am using. Your size will likely differ.")]),e._v(" "),o("h3",{attrs:{id:"ubuntu-thin-provisioning"}},[e._v("Ubuntu Thin Provisioning")]),e._v(" "),o("p",[e._v("Ensure thin provisioning tools are available in Ubuntu.")]),e._v(" "),o("highlight-code",{attrs:{lang:"bash"}},[o("p",[e._v("sudo apt-get update\nsudo apt-get install thin-provisioning-tools\n")])]),o("p"),e._v(" "),o("h3",{attrs:{id:"volumes"}},[e._v("Volumes")]),e._v(" "),o("p",[e._v("LVM requires you to specify three bits of information for storage:")]),e._v(" "),o("ol",[o("li",[e._v("Physical volumes")]),e._v(" "),o("li",[e._v("Volumes groups")]),e._v(" "),o("li",[e._v("Logical volumes")])]),e._v(" "),o("p",[e._v("Note, the following volume commands will be run as the root user. This can be done by using "),o("code",{pre:!0},[e._v("sudo")]),e._v(" or by logging in as\nroot, the option chosen here.")]),e._v(" "),o("h4",{attrs:{id:"physical-volumes"}},[e._v("Physical Volumes")]),e._v(" "),o("p",[e._v("The physical volumes represent available storage media. These are typically partitions and/or hard disks that can be\nused for storage, but in our example it will be a loopback device. To register our loopback device as a physical volume\nwe run")]),e._v(" "),o("highlight-code",{attrs:{lang:"bash"}},[o("p",[e._v('pvcreate /dev/loop5\n# Physical volume "/dev/loop5" successfully created\npvs -a\n# PV                        VG     Fmt  Attr PSize   PFree\n# /dev/loop5                       lvm2 ---  150.00g 150.00g\n')])]),o("p"),e._v(" "),o("h4",{attrs:{id:"volume-groups"}},[e._v("Volume Groups")]),e._v(" "),o("p",[e._v('Next we need to add a volume group. Volume groups can consist of multiple physical volumes grouped together, but in our\ncases we will only use our single loopback physical volume. To add this volume to a group we will call "docker", run the\nfollowing:')]),e._v(" "),o("highlight-code",{attrs:{lang:"bash"}},[o("p",[e._v('vgcreate docker /dev/loop5\n# Volume group "docker" successfully created\nvgs -a\n# VG     #PV #LV #SN Attr   VSize   VFree\n# docker   1   0   0 wz--n- 150.00g 150.00g\n')])]),o("p"),e._v(" "),o("h4",{attrs:{id:"logical-volumes"}},[e._v("Logical Volumes")]),e._v(" "),o("p",[e._v("Now that we have a volume group, we can start adding logical volumes. Logical volumes can have either thick or thin\nprovisioning with LVM. We will be creating thinly provisioned volumes for our snapshots. To do this we must first create\na thin provisioning pool which will be the total size of the storage space we have to work with. From here, when we\ncreate thin volumes we will create them inside this pool.")]),e._v(" "),o("p",[e._v("To create our thin pool, run the following command. Note that we use the option "),o("code",{pre:!0},[e._v("-l 100%FREE")]),e._v(" to specify that the thin\npool should be assigned all free space in the volume group.")]),e._v(" "),o("highlight-code",{attrs:{lang:"bash"}},[o("p",[e._v('lvcreate -l 100%FREE --thinpool thin_pool docker\n# Logical volume "thin_pool" created.\nlvs -a\n# LV                VG     Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert\n# [lvol0_pmspare]   docker ewi-------  76.00m'),o("br"),e._v("\n# thin_pool         docker twi-a-tz-- 149.85g             0.00   0.44"),o("br"),e._v("\n# [thin_pool_tdata] docker Twi-ao---- 149.85g"),o("br"),e._v("\n# [thin_pool_tmeta] docker ewi-ao----  76.00m\n")])]),o("p"),e._v(" "),o("p",[e._v("Now that the thin pool has been created, we can add a thin volumes and snapshots. The data directory for the mapping\nPostgres instance is about 134GB. However, since we are using thin provisioning let us create a 149GB volume for our\ndata.")]),e._v(" "),o("highlight-code",{attrs:{lang:"bash"}},[o("p",[e._v('lvcreate -V 149GB --thin --name thin_volume_1 docker/thin_pool\n# Logical volume "thin_volume_1" created.\nlvs -a\n# LV                VG     Attr       LSize   Pool      Origin Data%  Meta%  Move Log Cpy%Sync Convert\n# [lvol0_pmspare]   docker ewi-------  76.00m'),o("br"),e._v("\n# thin_pool         docker twi-a-tz-- 149.85g                  0.00   0.44"),o("br"),e._v("\n# [thin_pool_tdata] docker Twi-ao---- 149.85g"),o("br"),e._v("\n# [thin_pool_tmeta] docker ewi-ao----  76.00m"),o("br"),e._v("\n# thin_volume_1     docker Vwi-a-tz-- 149.00g thin_pool        0.00\n")])]),o("p"),e._v(" "),o("p",[e._v("When we create a snapshot, we will also be adding it to this pool. Sizes are not specified with thin snapshots, but as\nlong as the combined usage of the volume and the snapshot does not exceed the size of the pool (149.85G) we will be\nokay.")]),e._v(" "),o("p",[e._v("Now that we have our volume, lets format it with an EXT4 file system and mount it.")]),e._v(" "),o("highlight-code",{attrs:{lang:"bash"}},[o("p",[e._v("mkdir /mnt/vol1\nmkfs.ext4 /dev/docker/thin_volume_1\nmount /dev/docker/thin_volume_1 /mnt/vol1\ndf -h\n# Filesystem                        Size  Used Avail Use% Mounted on\n# /dev/mapper/docker-thin_volume_1  147G   60M  140G   1% /mnt/vol1\n")])]),o("p"),e._v(" "),o("h3",{attrs:{id:"snapshotting"}},[e._v("Snapshotting")]),e._v(" "),o("h4",{attrs:{id:"create"}},[e._v("Create")]),e._v(" "),o("p",[e._v("Now that the volumes have been created, restore your database to the volume and start your server. You can now create\na snapshot. The logical volume can remain mounted and in use during the creation of the snapshot. To create the\nsnapshot, run the following as the root user:")]),e._v(" "),o("highlight-code",{attrs:{lang:"bash"}},[o("p",[e._v("lvcreate -s --name thin_volume_1_snapshot docker/thin_volume_1\n")])]),o("p"),e._v(" "),o("p",[e._v("Now that the snapshot has been created, you are good to change and modify the PostgreSQL data however you wish.")]),e._v(" "),o("h4",{attrs:{id:"revert"}},[e._v("Revert")]),e._v(" "),o("p",[e._v("Once you are finished making changes and want to revert to the initial state of the database, you must first stop\nPostgres. Once this is done, run the following commands as root:")]),e._v(" "),o("highlight-code",{attrs:{lang:"bash"}},[o("p",[e._v("umount /mnt/vol1\nlvconvert --merge docker/thin_volume_1_snapshot\nlvcreate -s --name thin_volume_1_snapshot docker/thin_volume_1\nmount /dev/docker/thin_volume_1 /mnt/vol1\n")])]),o("p"),e._v(" "),o("p",[e._v('The first command unmounts the logical volume. The second command, resets the logical volume to the state it was at\nwhenever "thin_volume_1_snapshot" was created. By running this command, the snapshot is removed which is why we run the\nthird command to create a new snapshot. Finally, we remount the reverted logical volume. We can now restart Postgres and\nour data and server should be as they were when we created the initial snapshot.')])],1)}),[],!1,null,null,null);"function"==typeof s&&s(n);t.default=n.exports}}]);